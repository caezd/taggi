{"version":3,"file":"taggi.js","sources":["../src/index.js"],"sourcesContent":["/**\r\n * Taggi.js (cleaned)\r\n * ------------------\r\n * - Parses shortcodes per tag (single pass per element per tag).\r\n * - Optional regex-based extraction per tag.\r\n * - Rewrites the source HTML every run (shortcodes/regex are removed).\r\n * - Idempotent injection using invisible comment anchors (no DOM duplication).\r\n */\r\n\r\n// ---- Injection helpers (comment-anchored, no layout impact) ----\r\n\r\nfunction normalizeInside(pos) {\r\n    switch (pos) {\r\n        case \"afterbegin\":\r\n        case \"beforeend\":\r\n            return pos;\r\n        case \"after\": // legacy alias\r\n            return \"afterbegin\";\r\n        case \"before\": // legacy alias\r\n            return \"beforeend\";\r\n        default:\r\n            return \"beforeend\";\r\n    }\r\n}\r\n\r\n/**\r\n * Ajout : support de la syntaxe `inject: \"!selector\"` pour forcer `el.closest(selector)`\r\n * -------------------------------------------------------------------------------\r\n * - Si `inject` est une **fonction**, on appelle la fonction avec `el` (inchangé).\r\n * - Si `inject` est une **string** qui **commence par `!`**, on enlève le `!` et\r\n * on retourne **strictement** `el.closest(selector)`.\r\n * - Sinon (string sans `!`), on conserve le comportement souple précédent :\r\n * `el.closest(selector) || document.querySelector(selector)`.\r\n */\r\n\r\nfunction resolveInjectTarget(inject, el) {\r\n    if (typeof inject === \"function\") return inject(el);\r\n    if (typeof inject === \"string\") {\r\n        const raw = inject.trim();\r\n        if (!raw) return null;\r\n        if (raw.startsWith(\"!\")) {\r\n            const sel = raw.slice(1).trim();\r\n            if (!sel) return null;\r\n            return el.closest ? el.closest(sel) : null; // forcer closest uniquement\r\n        }\r\n        // comportement par défaut : d'abord proche, sinon global\r\n        return el.closest?.(raw) || document.querySelector(raw);\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction setCommentBlock(target, tagName, htmlList, pos = \"beforeend\") {\r\n    const { start, end } = ensureCommentBlock(target, tagName, pos);\r\n    // 1) Remove previous content between anchors\r\n    let n = start.nextSibling;\r\n    while (n && n !== end) {\r\n        const next = n.nextSibling;\r\n        n.parentNode.removeChild(n);\r\n        n = next;\r\n    }\r\n    // 2) Deduplicate and insert\r\n    const unique = Array.from(new Set(htmlList));\r\n    if (!unique.length) return;\r\n    const tpl = document.createElement(\"template\");\r\n    tpl.innerHTML = unique.join(\"\");\r\n    start.parentNode.insertBefore(tpl.content, end);\r\n}\r\n\r\nfunction ensureCommentBlock(target, tagName, pos = \"beforeend\") {\r\n    const startSig = `taggi:start:${tagName}`;\r\n    const endSig = `taggi:end:${tagName}`;\r\n    let start = findComment(target, startSig);\r\n    let end = findComment(target, endSig);\r\n    if (!start || !end) {\r\n        target.insertAdjacentHTML(pos, `<!--${startSig}--><!--${endSig}-->`);\r\n        start = findComment(target, startSig);\r\n        end = findComment(target, endSig);\r\n    }\r\n    return { start, end };\r\n}\r\n\r\nfunction findComment(root, text) {\r\n    const walker = document.createTreeWalker(\r\n        root,\r\n        NodeFilter.SHOW_COMMENT,\r\n        null\r\n    );\r\n    let n;\r\n    while ((n = walker.nextNode())) {\r\n        if (n.nodeValue === text) return n;\r\n    }\r\n    return null;\r\n}\r\n\r\n// --- helpers root & serialization ---\r\nfunction resolveRoot(root) {\r\n    if (!root) return document;\r\n    if (typeof root === \"string\") {\r\n        const tpl = document.createElement(\"template\");\r\n        tpl.innerHTML = root;\r\n        return tpl.content; // DocumentFragment\r\n    }\r\n    // Element | DocumentFragment | Document\r\n    return root;\r\n}\r\n\r\n/**\r\n * Taggi main class\r\n * ----------------\r\n * - config: { tagName: { selector, output, inject, position, regex } }\r\n * - options: { defaultSelector, fallbackOutput }\r\n */\r\nexport default class Taggi {\r\n    constructor(config, options = {}) {\r\n        this.config = config || {};\r\n        this.options = Object.assign(\r\n            {\r\n                defaultSelector: \".taggit\",\r\n                fallbackOutput: (content, tagName) =>\r\n                    `<span class=\"taggit\" data-tag=\"${tagName}\">${content}</span>`,\r\n            },\r\n            options\r\n        );\r\n        this.init();\r\n    }\r\n\r\n    /** Walk the config and apply parsing + injections. */\r\n    init(root) {\r\n        const scope = resolveRoot(root);\r\n        Object.entries(this.config).forEach(([tagName, tag]) => {\r\n            // 1) selectors -> unique elements\r\n            let selectors = tag.selector || this.options.defaultSelector;\r\n            if (!Array.isArray(selectors)) selectors = [selectors];\r\n            const elements = Array.from(\r\n                new Set(\r\n                    selectors.flatMap((sel) =>\r\n                        Array.from(scope.querySelectorAll(sel))\r\n                    )\r\n                )\r\n            );\r\n            if (!elements.length) return;\r\n\r\n            // 2) Aggregate rendered fragments per injection target\r\n            const buckets = new Map(); // Map<HTMLElement, string[]>\r\n\r\n            elements.forEach((el) => {\r\n                const original = el.innerHTML;\r\n                const parsed = tag.regex\r\n                    ? this.parseRegex(original, tag)\r\n                    : this.parseShortcodeForTag(original, tagName, tag);\r\n\r\n                if (parsed.content !== original) el.innerHTML = parsed.content;\r\n\r\n                if (tag.inject && parsed.found.length) {\r\n                    const target = resolveInjectTarget(tag.inject, el);\r\n                    if (!target) return;\r\n                    if (!buckets.has(target)) buckets.set(target, []);\r\n                    buckets.get(target).push(...parsed.found);\r\n                }\r\n            });\r\n\r\n            // 3) Injection: rewrite the per-tag comment block (no duplicates)\r\n            if (tag.inject && buckets.size) {\r\n                const pos = normalizeInside(tag.position);\r\n                for (const [target, arr] of buckets) {\r\n                    setCommentBlock(target, tagName, arr, pos);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Parse only the current tag's shortcodes: [tagName content] */\r\n    parseShortcodeForTag(text, tagName, tag) {\r\n        const re = /\\[([^\\s\\]]+)\\s+([^\\]]+)\\]/g;\r\n        const found = [];\r\n        const content = text.replace(re, (m, name, inner) => {\r\n            if (name !== tagName) return m;\r\n            const render =\r\n                (tag && typeof tag.output === \"function\" && tag.output) ||\r\n                this.options.fallbackOutput;\r\n            const html = render(inner, name);\r\n            found.push(html);\r\n            if (tag && tag.inject) return \"\";\r\n            return html;\r\n        });\r\n        return { content, found };\r\n    }\r\n\r\n    /**\r\n     * Regex-based extraction for a tag.\r\n     * NOTE: we ensure the 'g' flag to avoid infinite loops with exec().\r\n     * Expected: tag.output(...groups) -> string (rendered).\r\n     * Behavior: matched text is removed from source (returns via 'found' for injection).\r\n     */\r\n    parseRegex(text, tag) {\r\n        const found = [];\r\n        let content = text;\r\n\r\n        const flags = tag.regex.flags.includes(\"g\")\r\n            ? tag.regex.flags\r\n            : tag.regex.flags + \"g\";\r\n        const re = new RegExp(tag.regex.source, flags);\r\n        const reForReplace = new RegExp(tag.regex.source, flags);\r\n\r\n        let match;\r\n        while ((match = re.exec(text)) !== null) {\r\n            const rendered = tag.output(...match.slice(1));\r\n            found.push(rendered);\r\n        }\r\n\r\n        // Remove all matched segments from content\r\n        content = content.replace(reForReplace, \"\");\r\n\r\n        return { content, found };\r\n    }\r\n}\r\n"],"names":["setCommentBlock","target","tagName","htmlList","pos","start","end","startSig","endSig","findComment","insertAdjacentHTML","ensureCommentBlock","n","nextSibling","next","parentNode","removeChild","unique","Array","from","Set","length","tpl","document","createElement","innerHTML","join","insertBefore","content","root","text","walker","createTreeWalker","NodeFilter","SHOW_COMMENT","nextNode","nodeValue","constructor","config","options","this","Object","assign","defaultSelector","fallbackOutput","init","scope","resolveRoot","entries","forEach","tag","selectors","selector","isArray","elements","flatMap","sel","querySelectorAll","buckets","Map","el","original","parsed","regex","parseRegex","parseShortcodeForTag","inject","found","raw","trim","startsWith","slice","closest","querySelector","resolveInjectTarget","has","set","get","push","size","normalizeInside","position","arr","replace","m","name","inner","html","output","flags","includes","re","RegExp","source","reForReplace","match","exec","rendered"],"mappings":"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"}